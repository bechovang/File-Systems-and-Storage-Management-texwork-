%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                    %
%       TEMPLATE BÁO CÁO OSG202 - PHIÊN BẢN CẬP NHẬT (CHUẨN NHẤT)     %
%                                                                    %
% Tác giả: Gemini (Hiệu chỉnh dựa trên hình ảnh minh họa APA 7th)     %
% Ngày cập nhật: 20/10/2025                                          %
%                                                                    %
% CÁC CẬP NHẬT QUAN TRỌNG:                                            %
% 1. Trang bìa được định dạng lại khoảng cách cho giống hình ảnh.      %
% 2. Tự động lặp lại tiêu đề bài báo cáo ở đầu trang 2.                %
% 3. Tiêu đề mục cấp 1 (\section) được tự động căn giữa.               %
% 4. Giữ nguyên giãn dòng 1.5 theo yêu cầu của giảng viên.             %
% 5. Hỗ trợ tiếng Việt với XeLaTeX/LuaLaTeX                           %
%                                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% --- PHẦN PREAMBLE: KHAI BÁO CÁC GÓI VÀ THIẾT LẬP ---

\documentclass[12pt]{article}

\usepackage{float}
\usepackage{booktabs}       % Để tạo bảng biểu đẹp hơn
\usepackage{pifont}         % Để dùng ký hiệu checkmark/cross
\usepackage{hyperref}       % Tạo hyperlink cho mục lục và trích dẫn

% --- Các gói cần thiết cho định dạng ---
\usepackage[margin=1in]{geometry}

% --- Sử dụng XeLaTeX/LuaLaTeX cho hỗ trợ Unicode tốt hơn ---
\usepackage{fontspec}
\setmainfont{Times New Roman}
\setsansfont{Arial}

% --- Gói để chỉnh giãn dòng 1.5 ---
\usepackage{setspace}

% --- Gói cho trích dẫn và tài liệu tham khảo chuẩn APA 7th ---
\usepackage[style=apa, backend=biber, sortcites=true]{biblatex}
\addbibresource{bibliography.bib}

% --- Các gói hỗ trợ khác ---
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, linkcolor=black, filecolor=black,      
    urlcolor=blue, citecolor=black,
}

% --- Gói để tùy chỉnh header/footer (cho số trang) ---
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{} % Xóa tất cả header và footer mặc định
\rhead{\thepage} % Đặt số trang ở góc trên bên phải

% --- Sửa lỗi headheight ---
\setlength{\headheight}{14.5pt}

% --- Gói để căn giữa tiêu đề mục (\section) ---
\usepackage{sectsty}
\sectionfont{\centering} % Đặt tất cả \section căn giữa

% --- Bắt đầu nội dung tài liệu ---
\begin{document}

% --- TRANG BÌA (TITLE PAGE) - ĐÃ CẬP NHẬT ĐỊNH DẠNG ---
\begin{titlepage}
    \thispagestyle{fancy} % Áp dụng kiểu trang có số trang cho trang bìa
    \centering
    
    \vspace*{3\baselineskip} % Đẩy tiêu đề xuống 3-4 dòng từ lề trên
    
    {\Large \bfseries Group Report: Topic 4 – File Systems and Storage Management\par}
    
    \vspace{2\baselineskip} % Thêm 1 dòng trống (tương đương 2\baselineskip trong giãn dòng 1.5)
    
    {\large
        Nguyen Ngoc Phuc - SE203055 \\
        Dam Le Tuan Anh - SE204111\\
        Nguyen Quang Son\\
    }
    
    \vspace{1.5cm}
    
    {\large FPT University\par} % Thêm Affiliation
    
    \vspace{1.5cm}
    
    {\large OSG202 – Operating Systems\par}
    
    \vspace{1.5cm}
    
    {\large Le Bao Duy\par}
    
    \vspace{1.5cm}
    
    {\large October 24, 2025\par}
    
\end{titlepage}

% --- THIẾT LẬP GIÃN DÒNG 1.5 CHO TOÀN BỘ BÀI ---
\onehalfspacing 

% --- TẠO MỤC LỤC ---
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      BẮT ĐẦU NỘI DUNG CHÍNH                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% --- TỰ ĐỘNG LẶP LẠI TIÊU ĐỀ Ở ĐẦU TRANG 2 ---
\begin{center}
    \large \bfseries Group Report: A Comprehensive Analysis of File Systems and Storage Management
\end{center}
\vspace{1\baselineskip} % Thêm một khoảng trống nhỏ sau tiêu đề

\section{Introduction}
The 21st century has been marked by an explosion of digital information never before seen. As stated in the seminal works on storage management, newer technologies such as social networks or mobile devices are constantly producing a huge amount of data, creating what has been described as the ``expanding digital universe'' \parencite{EMC2012InformationStorage}.This exponential growth not only presents a challenge in terms of storage capacity but also places immense pressure on operating systems, requiring them to manage and retrieve data both efficiently and reliably.

Therefore, store devices performance control is now the focus issue and most critical bottleneck in contemporary computer system design \parencite{Pokharel2021}. The goal isn’t just to save data, but also organize it, protect and make it easily retrievable. The underlying problem is at the \textbf{file system}, the essential abstraction that mediates between application software on one hand and storage hardware on the other \parencite{Silberschatz2018}. The design and development of file systems is one among many aspects studied in the history of operating system emulation: from the largely retrograde File Allocation Table (FAT) only suitable for early personal computers to the robust, journaling NTFS and ext4, complexity has not been absent enctype. Performance, Reliability, and Advanced Features Every new generation exhibits impressive progress in performance, reliability, and other advanced features to cope with growing needs of the digital age \parencite{Tanenbaum2014}.


To study this important domain to the fullest extent, we formulate the following six leading aims of this paper:
\begin{enumerate}
    \item To articulate and analyze the elementary concepts of a file system: files, directories, meta-data, and blocks.
    \item To describe and contrast structures of three typical file systems: FAT, ext4, NTFS.
    \item Definition of Problem To compare and contrast the principal strategies implemented for allocating space to storage: contiguous, linked, and indexed.
    \item To study the different disk I/O scheduling algorithms: FCFS, SSTF, SCAN and C-SCAN.
    \item To explain the fundamental system acceleration and reliability techniques: caching, buffering and journaling.
    \item To perform a deep-dive case study of one real-world, heavily-used file system: Windows’ NTFS or Linux’s ext4.
\end{enumerate}

The report is organized as a constructive sequence of ideas. We introduce the theoretical background in Section 2 with a focus on relevant concepts and technologies. We provide a more detailed comparison and an in-depth case study illustrating the impact of our technique on real-world use casesin Section 3. In Section 4 we cover the wider implications, trade-offs, and how modern storage technologies can be exploited. Section 5 finally concludes the paper and provides prospects for future development of storage management research.


\section{Background / Literature Review}
%======================================================================
% Section 2.1: Fundamental Concepts
%======================================================================

\subsection{Fundamental Concepts}

Một hệ điều hành phải cung cấp một phương pháp lưu trữ và truy xuất thông tin nhất quán. Lớp trừu tượng mà hệ điều hành sử dụng để quản lý dữ liệu trên các thiết bị lưu trữ vật lý chính là hệ thống file (file system). Để hiểu được cách thức hoạt động của các kiến trúc hệ thống file phức tạp, trước tiên cần phải nắm vững các thành phần cấu tạo cơ bản của chúng, bao gồm: tệp (file), thư mục (directory), siêu dữ liệu (metadata), và khối (block).

\subsubsection{File (Tệp tin)}
Về cơ bản, một \textbf{file} là một tập hợp các thông tin hoặc bản ghi liên quan, được lưu trữ như một đơn vị có tên gọi duy nhất \parencite{EMC2012InformationStorage}. Dưới góc nhìn của người dùng, file là đơn vị logic nhỏ nhất để lưu trữ dữ liệu. Một hệ thống file cung cấp cho người dùng các chức năng cần thiết để tạo, sửa đổi, xóa và truy cập các file. Quyền truy cập vào một file được kiểm soát bởi các quyền hạn (permissions) do người sở hữu thiết lập và được duy trì bởi chính hệ thống file \parencite{Silberschatz2018}. Mỗi file thường được liên kết với một tập hợp các thuộc tính, bao gồm tên, loại, vị trí trên thiết bị lưu trữ, kích thước, quyền bảo vệ, và các dấu thời gian (ngày tạo, ngày sửa đổi cuối cùng).

\subsubsection{Directory (Thư mục)}
Để tổ chức hàng ngàn, thậm chí hàng triệu file một cách hiệu quả, hệ thống file sử dụng một cấu trúc phân cấp có tên là \textbf{thư mục} (directory). Một thư mục thực chất là một loại file đặc biệt, hoạt động như một "container" chứa các con trỏ trỏ đến nhiều file khác hoặc các thư mục con \parencite{EMC2012InformationStorage}. Tất cả các hệ thống file hiện đại đều duy trì một bản đồ con trỏ (pointer map) đến các thư mục, thư mục con và các file để tạo nên một cấu trúc cây (tree-like structure), cho phép người dùng và ứng dụng điều hướng trong hệ thống một cách logic thông qua các đường dẫn (path) tuyệt đối hoặc tương đối \parencite{Tanenbaum2014}.

\subsubsection{Metadata (Siêu dữ liệu)}
Ngoài bản thân dữ liệu của người dùng được lưu trong các file, hệ thống file còn phải duy trì một lượng lớn thông tin cấu trúc. Tập hợp các thông tin này được gọi chung là \textbf{siêu dữ liệu (metadata)} --- hay "dữ liệu về dữ liệu" \parencite{EMC2012InformationStorage}. Metadata có vai trò tối quan trọng trong việc quản lý và duy trì tính toàn vẹn của hệ thống file. 

Một ví dụ thực tế điển hình trong các hệ điều hành dựa trên UNIX như Linux là cấu trúc \textbf{inode}. Mỗi file và thư mục đều được liên kết với một inode duy nhất. Inode không chứa dữ liệu của file, mà chứa gần như mọi thông tin khác về file đó, bao gồm: chế độ truy cập (quyền đọc, ghi, thực thi), ID của người sở hữu và nhóm sở hữu, kích thước file, các dấu thời gian (lần truy cập cuối, lần sửa đổi cuối), và quan trọng nhất là một mảng các con trỏ trỏ đến các khối dữ liệu (data blocks) thực tế trên đĩa nơi nội dung file được lưu trữ \parencite{LinuxJournalInode}. Tương tự, trong hệ thống file NTFS của Windows, Master File Table (MFT) đóng vai trò là kho lưu trữ metadata trung tâm, nơi mỗi file được mô tả bằng một bản ghi MFT \parencite{Silberschatz2018}.

\subsubsection{Block (Khối)}
Trên phương diện vật lý, đĩa được chia thành các đơn vị có thể đánh địa chỉ, gọi là sector. Tuy nhiên, hệ thống file quản lý không gian đĩa thông qua một đơn vị lớn hơn gọi là \textbf{khối (block)}. Một khối hệ thống file (file system block) là "container" nhỏ nhất của không gian đĩa vật lý được cấp phát cho dữ liệu, và nó bao gồm một hoặc nhiều sector liền kề \parencite{EMC2012InformationStorage}. Kích thước của một khối (ví dụ: 4KB) được cố định tại thời điểm hệ thống file được tạo ra. Hầu hết các file đều có kích thước lớn hơn một khối, do đó chúng sẽ chiếm nhiều khối trên đĩa. Khi các khối mới được thêm vào hoặc xóa đi, các khối của một file có thể không còn nằm liền kề nhau, dẫn đến hiện tượng \textbf{phân mảnh (fragmentation)}, một yếu tố có thể ảnh hưởng đến hiệu năng truy xuất dữ liệu \parencite{Tanenbaum2014}.


%======================================================================
% PHẦN 2.2: File System Architectures}
%======================================================================


\subsection{File System Architectures}

Các hệ thống file đã trải qua một quá trình tiến hóa đáng kể, từ những cấu trúc đơn giản ban đầu đến các hệ thống phức tạp, đáng tin cậy và giàu tính năng được sử dụng ngày nay. Sự lựa chọn hệ thống file có ảnh hưởng sâu sắc đến hiệu năng, khả năng tương thích và độ an toàn dữ liệu của toàn bộ hệ thống. Báo cáo này sẽ tập trung phân tích ba kiến trúc tiêu biểu đại diện cho các hệ sinh thái lớn: FAT, ext4, và NTFS.

\subsubsection{FAT (File Allocation Table): Đại diện của sự đơn giản và tương thích}
Ra đời từ năm 1977 cùng với MS-DOS, \textbf{File Allocation Table (FAT)} là một trong những hệ thống file đơn giản và có sức ảnh hưởng lớn nhất \parencite{Bundele2018}. Cấu trúc của một phân vùng FAT bao gồm ba thành phần chính: một boot sector, bảng FAT, và vùng dữ liệu. Bảng FAT hoạt động như một danh sách liên kết (linked list) lưu trên đĩa, trong đó mỗi entry tương ứng với một cụm (cluster) trên vùng dữ liệu và chứa con trỏ trỏ đến cluster tiếp theo của file, hoặc một dấu hiệu đặc biệt để đánh dấu kết thúc file \parencite{Tanenbaum2014}.

Qua nhiều năm, FAT đã có các phiên bản khác nhau như FAT12, FAT16, và phổ biến nhất là \textbf{FAT32}. FAT32 sử dụng 32-bit cho mỗi entry trong bảng, cho phép nó hỗ trợ các phân vùng có kích thước lên tới 2TB và kích thước file tối đa là 4GB \parencite{Bundele2018}. Mặc dù có nhiều hạn chế—dễ bị phân mảnh, thiếu các tính năng hiện đại như journaling hay cơ chế bảo mật cấp file—sự đơn giản trong cấu trúc lại chính là ưu điểm lớn nhất của FAT. Nó đảm bảo khả năng tương thích gần như tuyệt đối giữa các hệ điều hành khác nhau, từ Windows, Linux, macOS cho đến các thiết bị điện tử. Vì lý do này, FAT32 vẫn là lựa chọn hàng đầu cho các thiết bị lưu trữ di động như USB flash drives và thẻ nhớ SD \parencite{Dhjaku2019}.

\subsubsection{ext4 (Fourth Extended Filesystem): Chuẩn mực cho Linux}
\textbf{ext4} là sự kế thừa và cải tiến vượt bậc từ các phiên bản tiền nhiệm là ext2 và ext3, và hiện là hệ thống file mặc định cho hầu hết các bản phân phối Linux. Một trong những cải tiến kiến trúc quan trọng nhất của ext4 là việc sử dụng \textbf{extents} thay cho cơ chế ánh xạ khối (block mapping) truyền thống của ext3. Thay vì phải duy trì một con trỏ cho từng khối dữ liệu riêng lẻ, một extent là một cấu trúc trỏ đến một dải các khối dữ liệu liền kề trên đĩa. Cơ chế này giúp giảm đáng kể sự phân mảnh, tăng hiệu năng truy xuất đối với các file lớn và đơn giản hóa việc quản lý metadata \parencite{Dhjaku2019}.

Bên cạnh đó, ext4 còn giới thiệu nhiều tính năng nâng cao khác như cấp phát trì hoãn (delayed allocation), cho phép hệ thống file thu thập nhiều khối ghi nhỏ trước khi cấp phát không gian thực sự, giúp đưa ra quyết định cấp phát tối ưu hơn. Hơn nữa, ext4 cải thiện cơ chế journaling bằng việc bổ sung checksum cho journal, giúp tăng cường độ tin cậy và phát hiện sớm các sự cố hỏng hóc \parencite{Dhjaku2019}. Với việc hỗ trợ 64-bit, ext4 có thể quản lý các phân vùng với kích thước lên tới 1 Exabyte (EB) và các file có kích thước lên tới 16 Terabyte (TB), đáp ứng đầy đủ các yêu cầu lưu trữ quy mô lớn hiện nay.

\subsubsection{NTFS (New Technology File System): Nền tảng của Windows}
Được giới thiệu lần đầu vào năm 1993, \textbf{NTFS} được thiết kế từ đầu để trở thành một hệ thống file hiện đại, mạnh mẽ và có khả năng mở rộng cho các hệ điều hành Windows NT \parencite{Cunningham2024}. Trái tim của NTFS là một cấu trúc dữ liệu mang tính cách mạng gọi là \textbf{Master File Table (MFT)}. Về bản chất, MFT là một file đặc biệt hoạt động như một cơ sở dữ liệu, chứa ít nhất một bản ghi (record) cho mỗi file và thư mục trên phân vùng. Mỗi bản ghi này lưu trữ tất cả metadata của file, chẳng hạn như tên, kích thước, dấu thời gian, và các thuộc tính khác. Đối với các file rất nhỏ, thậm chí cả dữ liệu của file cũng được lưu trực tiếp bên trong bản ghi MFT, giúp tăng tốc độ truy cập đáng kể \parencite{Dhjaku2019, Silberschatz2018}.

NTFS vượt trội hơn FAT ở mọi khía cạnh nhờ vào một loạt các tính năng nâng cao. Nó là một hệ thống file journaling hoàn chỉnh, đảm bảo khả năng phục hồi nhanh chóng và toàn vẹn dữ liệu sau sự cố hệ thống. Về bảo mật, NTFS cung cấp một mô hình phân quyền chi tiết thông qua \textbf{Access Control Lists (ACLs)}, cho phép quản trị viên thiết lập quyền truy cập cụ thể cho từng người dùng hoặc nhóm người dùng trên từng file/thư mục. Các tính năng khác bao gồm nén và mã hóa dữ liệu ở cấp độ file system (EFS), và Volume Shadow Copy Service (VSS) cho phép tạo các bản sao lưu tức thời \parencite{Tanenbaum2014}. Những đặc điểm này đã khiến NTFS trở thành lựa chọn không thể thiếu cho môi trường Windows, đặc biệt là trong các hệ thống máy chủ và doanh nghiệp.

\subsubsection{Comparative Summary}
Để tổng kết và làm nổi bật sự khác biệt giữa ba kiến trúc, Bảng \ref{tab:fs_comparison} dưới đây trình bày một so sánh chi tiết dựa trên các tiêu chí kỹ thuật và hiệu năng quan trọng. Dữ liệu trong bảng được tổng hợp từ các sách giáo khoa kinh điển và các bài báo nghiên cứu so sánh hiệu năng \parencite{Dhjaku2019, Bundele2018}.

 % % --- SẢN PHẨM 2: BẢNG SO SÁNH ---
 
 \begin{table}[H]
     \centering
     \caption{Comparative table of file system structures.}
     \label{tab:fs_comparison}
     \begin{tabular}{@{}llll@{}}
         \toprule
         \textbf{Feature} & \textbf{FAT32} & \textbf{ext4} & \textbf{NTFS} \\ 
         \midrule
         Max File Size     & 4 GB                  & 16 TB                 & 16 EB (theoretically) \\
         Max Volume Size   & 2 TB (up to 16 TB)    & 1 EB                  & 256 TB (practical)    \\
         Journaling        & No                  & Yes                 & Yes                 \\
         Metadata          & Minimal (FAT Table)   & Rich (Inodes)         & Very Rich (MFT)       \\
         Permissions       & Basic (Share-level)   & POSIX                 & ACLs                  \\
         Fragmentation     & High                  & Low (due to Extents)  & Medium                \\
         Performance       & Low                   & High                  & High                  \\
         Ideal Use         & Portable Devices      & Linux Systems         & Windows Systems       \\ 
         \bottomrule
     \end{tabular}
 \end{table}



%======================================================================
% PHẦN 2.3: CÁC PHƯƠNG PHÁP CẤP PHÁT
%======================================================================

\subsection{Allocation Methods}
Phương pháp cấp phát (Allocation Method) định nghĩa cách hệ điều hành quản lý và sắp xếp các khối đĩa (disk blocks) cho một tệp tin. Việc lựa chọn phương pháp cấp phát ảnh hưởng trực tiếp đến hiệu năng hệ thống, hiệu quả sử dụng không gian lưu trữ và sự phức tạp trong việc quản lý tệp. Ba phương pháp cơ bản và kinh điển nhất là: cấp phát liên tục, cấp phát nối kết, và cấp phát theo chỉ mục \parencite{Silberschatz2018}.

\subsubsection{Contiguous Allocation (Cấp phát Liên tục)}
Cơ chế của phương pháp cấp phát liên tục yêu cầu mỗi tệp tin phải chiếm một dãy các khối liền kề nhau trên đĩa. Để quản lý, mục nhập thư mục (directory entry) cho mỗi tệp chỉ cần lưu hai thông tin: địa chỉ của khối bắt đầu và tổng số khối được cấp phát \parencite{Tanenbaum2014}.

Ưu điểm lớn nhất của phương pháp này là hiệu năng. Nó hỗ trợ truy cập tuần tự (sequential access) cực kỳ hiệu quả vì đầu đọc đĩa chỉ cần di chuyển đến khối đầu tiên và sau đó đọc liên tục mà không cần thực hiện thêm thao tác tìm kiếm (seek). Truy cập ngẫu nhiên (random access) cũng rất nhanh, vì địa chỉ của bất kỳ khối nào trong tệp cũng có thể được tính toán một cách dễ dàng từ địa chỉ bắt đầu \parencite{Fiveable2025}.

Tuy nhiên, nhược điểm chính của nó là vấn đề \textbf{phân mảnh ngoài (external fragmentation)}. Theo thời gian, khi các tệp được tạo và xóa, không gian trống trên đĩa bị chia thành nhiều mảnh nhỏ không liền kề. Điều này dẫn đến tình huống có đủ tổng không gian trống để lưu một tệp mới, nhưng không có một khoảng trống liền kề nào đủ lớn. Một vấn đề khác là khó khăn trong việc thay đổi kích thước tệp sau khi nó đã được tạo, vì không gian liền kề có thể đã bị chiếm dụng \parencite{Silberschatz2018}.

\subsubsection{Linked Allocation (Cấp phát Nối kết)}
Để giải quyết vấn đề phân mảnh ngoài, phương pháp cấp phát nối kết ra đời. Theo cơ chế này, mỗi tệp là một danh sách liên kết (linked list) của các khối đĩa, và các khối này có thể nằm rải rác ở bất kỳ đâu trên đĩa. Mỗi khối chứa dữ liệu của tệp và một con trỏ (pointer) trỏ đến khối tiếp theo. Mục nhập thư mục chỉ cần lưu địa chỉ của khối đầu tiên \parencite{Silberschatz2018}.

Ưu điểm chính của phương pháp này là nó loại bỏ hoàn toàn phân mảnh ngoài và cho phép tệp dễ dàng tăng kích thước mà không cần phải di chuyển. Tuy nhiên, nó cũng có những nhược điểm đáng kể. Truy cập ngẫu nhiên trở nên rất chậm và không hiệu quả, vì để truy cập đến khối thứ \textit{i}, hệ thống phải duyệt tuần tự qua \textit{i-1} khối đầu tiên. Thêm vào đó, việc lưu trữ con trỏ trong mỗi khối gây tốn một phần không gian lưu trữ, và nếu một con trỏ bị hỏng, phần còn lại của tệp có thể bị mất \parencite{Tanenbaum2014}. Hệ thống file \textbf{FAT (File Allocation Table)} là một biến thể nổi tiếng của phương pháp này, trong đó các con trỏ được tập trung vào một bảng riêng biệt (bảng FAT) thay vì nằm rải rác trong các khối dữ liệu, giúp cải thiện phần nào tốc độ truy cập ngẫu nhiên nếu bảng FAT được nạp vào bộ nhớ \parencite{Fiveable2025}.

\subsubsection{Indexed Allocation (Cấp phát theo Chỉ mục)}
Phương pháp cấp phát theo chỉ mục giải quyết được nhược điểm truy cập ngẫu nhiên chậm của cấp phát nối kết. Cơ chế của nó là tập hợp tất cả các con trỏ của một tệp vào một khối đặc biệt gọi là \textbf{khối chỉ mục (index block)}. Mục nhập thư mục sẽ trỏ đến khối chỉ mục này. Mỗi mục trong khối chỉ mục lại trỏ đến một khối dữ liệu thực tế của tệp \parencite{Silberschatz2018}.

Phương pháp này hỗ trợ truy cập ngẫu nhiên hiệu quả vì hệ thống có thể đọc toàn bộ "bản đồ" của tệp chỉ bằng cách nạp khối chỉ mục vào bộ nhớ. Nó cũng không bị phân mảnh ngoài. Tuy nhiên, nó lại gây lãng phí không gian đối với các tệp rất nhỏ (vì phải tốn nguyên một khối chỉ để lưu vài con trỏ) và bị giới hạn kích thước tệp nếu chỉ sử dụng một khối chỉ mục duy nhất \parencite{IRJMETS2021}. Để giải quyết giới hạn này, các hệ thống file hiện đại như UNIX đã phát triển các cơ chế phức tạp hơn như \textbf{chỉ mục đa cấp (multi-level indexing)}, sử dụng các con trỏ gián tiếp đơn, đôi, ba (single, double, triple indirect pointers) để có thể quản lý các tệp có kích thước cực lớn \parencite{Tanenbaum2014}.

Hình \ref{fig:indexed_allocation_diagram} minh họa cách ánh xạ từ địa chỉ logic sang các khối vật lý thông qua một khối chỉ mục duy nhất.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{image/diagram mapping Indexed Allocation.jpg}
    \caption{Logical $\rightarrow$ Physical Address Mapping using Indexed Allocation.}
    \label{fig:indexed_allocation_diagram}
\end{figure}

\subsubsection{Hybrid Approaches and Modern Solutions}
Nhận thấy rằng không có phương pháp đơn lẻ nào là hoàn hảo, các nghiên cứu gần đây đã đề xuất các giải pháp lai (hybrid) nhằm kết hợp ưu điểm của các phương pháp khác nhau. Một ví dụ điển hình là hệ thống "Hybrid Indexed and Linked List File Allocation System" được đề xuất bởi Rahman và Siddiqua. Hệ thống này đề xuất một chiến lược linh hoạt: đối với các tệp có kích thước nhỏ (ví dụ: dưới 10 khối), nó sẽ sử dụng phương pháp cấp phát nối kết để tránh lãng phí không gian cho một khối chỉ mục không cần thiết. Khi tệp phát triển vượt qua một ngưỡng nhất định, hệ thống sẽ tự động chuyển sang sử dụng cấp phát theo chỉ mục để đảm bảo hiệu năng truy cập ngẫu nhiên tốt hơn cho các tệp lớn hơn \parencite{IRJMETS2021}. Cách tiếp cận này thể hiện một nỗ lực nhằm tối ưu hóa việc cấp phát dựa trên đặc tính của từng tệp, thay vì áp dụng một quy tắc duy nhất cho toàn bộ hệ thống.

%======================================================================
% PHẦN 2.4: LẬP LỊCH TRUY XUẤT ĐĨA
%======================================================================
% % https://calculator.pisqre.com/disk-scheduling
% % https://seektime.app/ : tính vẽ đường này nọ cũng đẹp
% % TODO: BẮT BUỘC THÊM PHẦN TÍNH TOÁN VÀ SƠ ĐỒ GANTT TẠI ĐÂY
% % Dựa trên dàn bài nâng cao, bạn cần thêm một ví dụ cụ thể:
% % - Example Request Queue: 98, 183, 37, 122, 14, 124, 65, 67
% % - Starting position: 53
% % - Tính toán Total Head Movement cho từng thuật toán.
% % - Vẽ sơ đồ Gantt minh họa cho mỗi thuật toán.
% \includegraphics[width=\textwidth]{placeholder.png}

\subsection{Disk I/O Scheduling}

One of the primary causes of a performance "bottleneck" for traditional computer systems is the difference in speed between the CPU/main memory and mechanical storage media such as hard disk drives (HDDs) \parencite{Pokharel2021}. For an HDD, data access time has two fundamental parts: seek time—the duration for the read/write head to move to the correct cylinder, and rotational latency—the duration for the sector requested to rotate to the location of the head. Of these, seek time will be the most costly and fluctuating part \parencite{KansalDiskScheduling}. Thus, in a system that supports multitasking where multiple processes concurrently initiate I/O requests, the operating system should have a facility to schedule the completion of the same. It is called disk scheduling, where its foremost aim is to minimize head movement and therefore reduce the average response time as well as increase the system throughput \parencite{GeeksForGeeks2025IO}. The following algorithms are the most widely used methods.

\subsubsection{FCFS (First-Come, First-Served)}
Đây là thuật toán lập lịch đơn giản nhất, trong đó các yêu cầu I/O được phục vụ theo đúng thứ tự chúng đến. FCFS đảm bảo tính công bằng tuyệt đối vì không có yêu cầu nào bị "đói" (starvation). Tuy nhiên, nó không thực hiện bất kỳ sự tối ưu hóa nào về chuyển động của đầu đọc. Điều này có thể dẫn đến những chuyển động rất lớn và không hiệu quả của đầu đọc qua lại trên bề mặt đĩa, làm giảm đáng kể hiệu năng tổng thể của hệ thống \parencite{GeeksForGeeks2025IO}.

\subsubsection{SSTF (Shortest Seek Time First)}
Thuật toán SSTF lựa chọn phục vụ yêu cầu có khoảng cách (seek time) ngắn nhất so với vị trí hiện tại của đầu đọc. Về cơ bản, nó ưu tiên các yêu cầu "gần nhất", bất kể chúng đến khi nào. SSTF cải thiện đáng kể so với FCFS bằng cách giảm thiểu tổng quãng đường di chuyển của đầu đọc. Tuy nhiên, nhược điểm lớn của nó là khả năng gây ra \textbf{starvation}: các yêu cầu ở những cylinder xa (ở rìa trong hoặc rìa ngoài của đĩa) có thể phải chờ đợi vô tận nếu các yêu cầu mới liên tục xuất hiện ở gần vị trí hiện tại của đầu đọc \parencite{GeeksForGeeks2025IO, KansalDiskScheduling}.

\subsubsection{SCAN (Elevator Algorithm)}
Thuật toán SCAN, hay còn gọi là thuật toán thang máy, hoạt động bằng cách để đầu đọc di chuyển từ một đầu của đĩa và đi về phía đầu kia, phục vụ tất cả các yêu cầu trên đường đi của nó. Khi đến đầu kia, nó đảo ngược hướng và lặp lại quá trình. SCAN giải quyết được vấn đề starvation của SSTF vì nó đảm bảo sẽ đi qua tất cả các cylinder. Tuy nhiên, nó có một sự thiên vị nhẹ đối với các cylinder ở giữa và có thể gây ra thời gian chờ đợi lâu cho các yêu cầu vừa mới bị đầu đọc đi qua \parencite{GeeksForGeeks2025IO}.

\subsubsection{C-SCAN (Circular SCAN)}
C-SCAN là một biến thể của SCAN nhằm cung cấp thời gian chờ đợi đồng đều hơn. Tương tự SCAN, đầu đọc di chuyển từ đầu này sang đầu kia của đĩa, phục vụ các yêu cầu. Tuy nhiên, khi đến đầu kia, thay vì đảo ngược hướng, nó sẽ thực hiện một "bước nhảy" lớn, quay trở lại ngay lập tức vị trí bắt đầu và tiếp tục quét theo cùng một hướng. Bằng cách chỉ phục vụ các yêu cầu theo một chiều, C-SCAN đảm bảo rằng các yêu cầu ở cylinder ngoài cùng và trong cùng có thời gian chờ đợi tương đương nhau, loại bỏ sự thiên vị của thuật toán SCAN \parencite{KansalDiskScheduling, GeeksForGeeks2025IO}.

\subsubsection{Quantitative Analysis with an Example}
Để minh họa hiệu quả của các thuật toán, chúng ta sẽ xem xét một ví dụ cụ thể. Giả sử có một hàng đợi các yêu cầu truy cập đến các cylinder sau: \textbf{98, 183, 37, 122, 14, 124, 65, 67}. Đĩa có tổng cộng 200 cylinder (từ 0 đến 199) và vị trí bắt đầu của đầu đọc là cylinder \textbf{53}.

\paragraph{FCFS:}
\begin{itemize}
    \item \textbf{Sequence:} 53 \(\rightarrow\) 98 \(\rightarrow\) 183 \(\rightarrow\) 37 \(\rightarrow\) 122 \(\rightarrow\) 14 \(\rightarrow\) 124 \(\rightarrow\) 65 \(\rightarrow\) 67
    \item \textbf{Total Head Movement:} (98-53) + (183-98) + (183-37) + (122-37) + (122-14) + (124-14) + (124-65) + (67-65) = \textbf{640} cylinders.
\end{itemize}

\paragraph{SSTF:}
\begin{itemize}
    \item \textbf{Sequence:} 53 \(\rightarrow\) 65 \(\rightarrow\) 67 \(\rightarrow\) 37 \(\rightarrow\) 14 \(\rightarrow\) 98 \(\rightarrow\) 122 \(\rightarrow\) 124 \(\rightarrow\) 183
    \item \textbf{Total Head Movement:} (65-53) + (67-65) + (67-37) + (37-14) + (98-14) + (122-98) + (124-122) + (183-124) = \textbf{236} cylinders.
\end{itemize}

\paragraph{SCAN (assuming moving towards 199 initially):}
\begin{itemize}
    \item \textbf{Sequence:} 53 \(\rightarrow\) 65 \(\rightarrow\) 67 \(\rightarrow\) 98 \(\rightarrow\) 122 \(\rightarrow\) 124 \(\rightarrow\) 183 \(\rightarrow\) 199 \(\rightarrow\) 37 \(\rightarrow\) 14
    \item \textbf{Total Head Movement:} (199 - 53) + (199 - 14) = 146 + 185 = \textbf{331} cylinders.
\end{itemize}

\paragraph{C-SCAN (assuming moving towards 199 initially):}
\begin{itemize}
    \item \textbf{Sequence:} 53 \(\rightarrow\) 65 \(\rightarrow\) 67 \(\rightarrow\) 98 \(\rightarrow\) 122 \(\rightarrow\) 124 \(\rightarrow\) 183 \(\rightarrow\) 199 \(\rightarrow\) 0 \(\rightarrow\) 14 \(\rightarrow\) 37
    \item \textbf{Total Head Movement:} (199 - 53) + (199 - 0) + (37 - 0) = 146 + 199 + 37 = \textbf{382} cylinders.
\end{itemize}

% TODO: BẮT BUỘC THÊM BIỂU ĐỒ GANTT TẠI ĐÂY
% Bạn có thể dùng công cụ draw.io để vẽ các biểu đồ minh họa chuyển động của đầu đọc cho từng thuật toán,
% sau đó chèn vào file LaTeX dưới dạng hình ảnh.

\subsubsection{Discussion and Extensions}
Từ kết quả tính toán trên, có thể thấy SSTF mang lại hiệu quả cao nhất cho trường hợp cụ thể này. Tuy nhiên, các thuật toán SCAN và C-SCAN vẫn là những lựa chọn phổ biến trong thực tế do khả năng tránh được starvation. Một điểm yếu của SCAN và C-SCAN là chúng luôn di chuyển đến tận cùng của đĩa, ngay cả khi không có yêu cầu nào ở đó. Để tối ưu hóa điều này, các biến thể \textbf{LOOK} và \textbf{C-LOOK} đã được giới thiệu. Các thuật toán này hoạt động tương tự như SCAN và C-SCAN nhưng chỉ di chuyển đến yêu cầu cuối cùng theo một hướng rồi đảo chiều, do đó loại bỏ được các chuyển động không cần thiết đến cuối đĩa \parencite{KansalDiskScheduling, Pokharel2021}. Một nghiên cứu so sánh toàn diện của Pokharel (2021) trên 20 bộ dữ liệu khác nhau đã chỉ ra rằng, trong hầu hết các trường hợp, C-LOOK là thuật toán cho tổng quãng đường di chuyển và thời gian tìm kiếm trung bình thấp nhất, do đó tối đa hóa được thông lượng của thiết bị lưu trữ \parencite{Pokharel2021}.

%======================================================================
% PHẦN 2.5: CÁC KỸ THUẬT TĂNG HIỆU NĂNG VÀ ĐỘ TIN CẬY (PHIÊN BẢN NÂNG CAO)
%======================================================================

\subsection{Performance \& Reliability Techniques}
Ngoài việc tối ưu hóa thứ tự truy xuất vật lý, hệ điều hành còn triển khai các kỹ thuật ở tầng logic để tăng cường hiệu năng và đảm bảo tính toàn vẹn của dữ liệu. Ba trong số các cơ chế quan trọng và phổ biến nhất trong các hệ thống file hiện đại là caching, buffering và journaling.

\subsubsection{Caching and Buffering}
Mặc dù thường được sử dụng thay thế cho nhau, \textbf{buffering} và \textbf{caching} là hai khái niệm riêng biệt với các mục tiêu khác nhau nhằm giải quyết nút thắt cổ chai về hiệu năng I/O.

\textbf{Buffering} là một kỹ thuật sử dụng một vùng nhớ đệm (buffer) để tạm thời lưu trữ dữ liệu trong quá trình truyền tải giữa hai thiết bị có tốc độ khác nhau. Mục đích chính của nó là để làm "mượt" (smooth) luồng dữ liệu và cho phép các tiến trình tiếp tục mà không cần chờ đợi thao tác I/O vật lý hoàn tất. Ví dụ, khi một ứng dụng thực hiện thao tác ghi, dữ liệu có thể được sao chép vào một buffer trong kernel, và system call sẽ trả về ngay lập tức. Sau đó, kernel sẽ tự sắp xếp để ghi dữ liệu từ buffer xuống đĩa ở chế độ nền. Dữ liệu trong buffer là dữ liệu gốc đang chờ được xử lý và thường chỉ tồn tại trong thời gian ngắn \parencite{GeeksForGeeks2025BufferCache}.

Mặt khác, \textbf{caching} là kỹ thuật lưu trữ một \textit{bản sao} của dữ liệu thường xuyên được truy cập từ một thiết bị lưu trữ chậm (như HDD) vào một vùng nhớ nhanh hơn (như RAM). Mục tiêu của caching là để giảm độ trễ truy cập cho các lần \textit{đọc} trong tương lai. Khi một yêu cầu đọc dữ liệu được đưa ra, hệ thống sẽ kiểm tra cache trước tiên. Nếu dữ liệu có sẵn trong cache (một "cache hit"), nó sẽ được trả về ngay lập tức mà không cần phải truy cập vào thiết bị chậm. Nếu không (một "cache miss"), dữ liệu sẽ được đọc từ thiết bị chậm, trả về cho yêu cầu, và đồng thời một bản sao của nó sẽ được lưu vào cache để phục vụ cho các lần truy cập sau này \parencite{GeeksForGeeks2025BufferCache}. Hầu hết các hệ điều hành hiện đại đều tích hợp cả hai cơ chế này vào một hệ thống quản lý bộ nhớ thống nhất, thường được gọi là \textbf{unified page cache}, để quản lý bộ nhớ một cách linh hoạt giữa các tiến trình và các hoạt động I/O của hệ thống file \parencite{Silberschatz2018}.

\subsubsection{Journaling (Ghi nhật ký)}
Một trong những thách thức lớn nhất của hệ thống file là duy trì được trạng thái nhất quán (consistent state) khi xảy ra sự cố đột ngột như mất điện hoặc hệ thống bị treo. Một thao tác logic đơn giản như xóa file có thể yêu cầu nhiều thao tác ghi vật lý riêng biệt vào metadata (ví dụ: sửa đổi bitmap, cập nhật inode, thay đổi nội dung thư mục). Nếu sự cố xảy ra giữa các bước này, hệ thống file có thể rơi vào trạng thái không nhất quán, dẫn đến mất dữ liệu hoặc rò rỉ không gian lưu trữ \parencite{LibreTextsJournaling}. Việc sửa chữa một hệ thống file không nhất quán bằng các công cụ như `fsck` thường rất tốn thời gian vì nó phải quét toàn bộ cấu trúc metadata của đĩa.

Để giải quyết vấn đề này, các hệ thống file hiện đại triển khai cơ chế \textbf{ghi nhật ký (journaling)}, hay còn gọi là \textbf{write-ahead logging}. Ý tưởng cốt lõi là, trước khi ghi trực tiếp các thay đổi vào cấu trúc chính của hệ thống file, một bản ghi mô tả "ý định" của các thay đổi đó sẽ được ghi vào một vùng đặc biệt gọi là \textbf{journal} (nhật ký). Chỉ sau khi giao dịch (transaction) này được ghi an toàn vào journal và được đánh dấu là đã cam kết (committed), hệ thống mới bắt đầu quá trình \textbf{checkpointing} --- tức là ghi các thay đổi thực sự vào vị trí cố định của chúng. Trong trường hợp xảy ra sự cố, khi hệ thống khởi động lại, nó chỉ cần đọc lại journal và "phát lại" (replay) các giao dịch đã được cam kết nhưng chưa hoàn thành checkpointing để đưa hệ thống file trở lại trạng thái nhất quán một cách nhanh chóng \parencite{Prabhakaran2005journaling, Jones2008Anatomy}.

Các hệ thống file journaling thường triển khai ba chế độ hoạt động khác nhau, thể hiện sự đánh đổi giữa hiệu năng và mức độ bảo vệ dữ liệu:
\begin{itemize}
    \item \textbf{Writeback Mode:} Đây là chế độ có hiệu năng cao nhất nhưng rủi ro nhất. Trong chế độ này, chỉ có metadata được ghi vào journal. Dữ liệu của file được ghi trực tiếp vào vị trí cố định của nó mà không có bất kỳ sự đồng bộ nào với việc ghi metadata. Điều này có nghĩa là metadata có thể được ghi trước hoặc sau dữ liệu. Nếu xảy ra sự cố, hệ thống file có thể phục hồi về trạng thái metadata nhất quán, nhưng dữ liệu của file có thể bị cũ hoặc chứa dữ liệu rác \parencite{Jones2008Anatomy}.

    \item \textbf{Ordered Mode:} Đây là chế độ mặc định trên hầu hết các hệ thống Linux (bao gồm cả ext3 và ext4) và là một sự cân bằng tốt giữa hiệu năng và an toàn. Tương tự như writeback, chỉ có metadata được ghi vào journal. Tuy nhiên, chế độ này áp đặt một trật tự ghi nghiêm ngặt: dữ liệu của file \textit{phải} được ghi vào vị trí cố định của nó \textit{trước khi} metadata liên quan đến nó được commit vào journal. Trật tự này đảm bảo rằng metadata sẽ không bao giờ trỏ đến các khối dữ liệu chưa được ghi hoặc chứa dữ liệu rác, do đó ngăn ngừa được tình trạng hỏng dữ liệu sau khi phục hồi, mặc dù vẫn có thể mất các cập nhật mới nhất \parencite{Prabhakaran2005journaling}.

    \item \textbf{Data Mode (Full Data Journaling):} Đây là chế độ an toàn nhất nhưng cũng chậm nhất. Trong chế độ này, cả \textbf{metadata và dữ liệu} của file đều được ghi vào journal trước khi được checkpoint. Điều này có nghĩa là mỗi khối dữ liệu được ghi hai lần: một lần vào journal và một lần vào vị trí cuối cùng của nó. Chế độ này đảm bảo tính nhất quán ở mức cao nhất; sau sự cố, file sẽ ở trạng thái cũ hoặc mới một cách toàn vẹn. Tuy nhiên, việc ghi kép này làm giảm đáng kể thông lượng ghi của hệ thống \parencite{Jones2008Anatomy}.
\end{itemize}



%======================================================================
% PHẦN 3: CASE STUDY NTFS
%======================================================================

\section{Analysis \& Case Study: NTFS Deep Dive}

%======================================================================
% PHẦN 3.1: PHÂN TÍCH SO SÁNH TỔNG HỢP
%======================================================================

\subsection{Comparative Analysis}

Sau khi đã khảo sát các khái niệm lý thuyết và kiến trúc cơ bản của ba hệ thống file tiêu biểu trong Phần 2, phần này sẽ tiến hành tổng hợp và so sánh trực tiếp các đặc tính của chúng dựa trên các tiêu chí quan trọng về hiệu năng, độ tin cậy, bảo mật và các trường hợp sử dụng thực tế. Phân tích này sẽ làm nổi bật sự đánh đổi (trade-offs) giữa các thiết kế và tạo tiền đề cho phần nghiên cứu điển hình chuyên sâu về NTFS.

\subsubsection{Performance Comparison}
Hiệu năng của một hệ thống file phụ thuộc rất lớn vào cách nó quản lý việc cấp phát khối và metadata. Dựa trên kiến trúc, chúng ta có thể so sánh hiệu năng lý thuyết của FAT32, ext4 và NTFS trong các kịch bản sau:
\begin{itemize}
    \item \textbf{Truy cập tuần tự (Sequential Access):} Cả ext4 và NTFS đều cho hiệu năng vượt trội trong kịch bản này. ext4 sử dụng cơ chế \textbf{extents}, cho phép nó cấp phát các dải khối lớn và liền kề, giảm thiểu đáng kể chuyển động của đầu đọc \parencite{Dhjaku2019}. NTFS cũng có các thuật toán cấp phát thông minh để giữ cho các file lớn càng liền kề càng tốt. Ngược lại, FAT32, với bản chất danh sách liên kết, rất dễ bị phân mảnh, khiến cho việc đọc một file lớn, tuần tự có thể yêu cầu nhiều thao tác tìm kiếm (seek) tốn kém.

    \item \textbf{Truy cập ngẫu nhiên (Random Access):} Các hệ thống file dựa trên chỉ mục như ext4 và NTFS lại chiếm ưu thế. Cấu trúc inode với các con trỏ đa cấp của ext4 và kiến trúc MFT tập trung của NTFS cho phép hệ thống nhanh chóng định vị bất kỳ khối dữ liệu nào của file chỉ qua một vài lần truy cập metadata. FAT32, một lần nữa, tỏ ra yếu thế vì việc truy cập một khối ở giữa file đòi hỏi phải duyệt qua chuỗi con trỏ từ đầu \parencite{Silberschatz2018}.

    \item \textbf{Xử lý file nhỏ:} NTFS có một lợi thế đặc biệt với các file rất nhỏ nhờ tính năng \textbf{dữ liệu nội trú (resident data)}. Nếu dữ liệu của một file đủ nhỏ, nó có thể được lưu trữ trực tiếp bên trong bản ghi MFT của file đó, loại bỏ hoàn toàn nhu cầu truy cập vào các khối dữ liệu bên ngoài và mang lại tốc độ truy cập cực nhanh \parencite{Tanenbaum2014}. ext4 cũng xử lý file nhỏ hiệu quả bằng cách cố gắng gom chúng vào cùng một block group để tăng tính cục bộ (locality).

    \item \textbf{Xử lý file lớn:} Giới hạn kích thước file 4GB của FAT32 khiến nó không còn phù hợp. Cả ext4 và NTFS đều hỗ trợ kích thước file và phân vùng cực lớn, lên đến hàng Terabyte và Exabyte, đáp ứng tốt các nhu-cầu lưu trữ hiện đại \parencite{Dhjaku2019}.
\end{itemize}

\subsubsection{Security and Reliability}
Về độ tin cậy và bảo mật, sự khác biệt giữa các hệ thống file là rất rõ rệt.
\begin{itemize}
    \item \textbf{Độ tin cậy (Reliability):} Lợi thế lớn nhất của ext4 và NTFS so với FAT32 là việc hỗ trợ \textbf{journaling}. Như đã phân tích ở Mục 2.5.3, cơ chế ghi nhật ký đảm bảo rằng hệ thống file có thể nhanh chóng phục hồi về một trạng thái nhất quán sau sự cố đột ngột, giảm thiểu nguy cơ hỏng cấu trúc metadata và rút ngắn đáng kể thời gian kiểm tra đĩa (fsck) khi khởi động lại \parencite{Prabhakaran2005journaling}. FAT32 không có cơ chế này, khiến nó dễ bị lỗi và mất dữ liệu hơn.

    \item \textbf{Bảo mật (Security):} FAT32 chỉ cung cấp các cơ chế bảo mật rất cơ bản ở cấp độ chia sẻ (share-level). Ngược lại, ext4 và NTFS đều được xây dựng cho các hệ điều hành đa người dùng. ext4 sử dụng mô hình phân quyền \textbf{POSIX} kinh điển của UNIX, định nghĩa quyền truy cập cho ba lớp: người sở hữu (owner), nhóm sở hữu (group), và những người khác (other). Trong khi đó, NTFS triển khai một mô hình linh hoạt và mạnh mẽ hơn nhiều gọi là \textbf{Access Control Lists (ACLs)}. Với ACLs, quản trị viên có thể gán hoặc từ chối các quyền cụ thể (đọc, ghi, thực thi, xóa, v.v.) cho nhiều người dùng và nhóm khác nhau trên cùng một file hoặc thư mục, cho phép kiểm soát truy cập ở mức độ chi tiết hơn hẳn \parencite{Bundele2018}.
\end{itemize}

\subsubsection{Use Case Scenarios}
Từ những phân tích trên, vai trò của mỗi hệ thống file trong các môi trường khác nhau được định hình rõ ràng:
\begin{itemize}
    \item \textbf{FAT32:} Mặc dù đã lỗi thời về mặt công nghệ, sự đơn giản và khả năng tương thích gần như toàn cầu giúp FAT32 (và người kế nhiệm là exFAT) vẫn là lựa chọn số một cho các thiết bị lưu trữ di động cần trao đổi dữ liệu giữa nhiều nền tảng khác nhau, như USB flash drives và thẻ nhớ SD.

    \item \textbf{ext4:} Là hệ thống file bản địa của hệ sinh thái Linux, ext4 là sự lựa chọn mặc định cho hầu hết mọi thứ, từ máy chủ doanh nghiệp, máy tính để bàn cho đến các thiết bị nhúng chạy Linux. Nó cung cấp một sự cân bằng tuyệt vời giữa hiệu năng, độ tin cậy và sự ổn định trong một môi trường mã nguồn mở.

    \item \textbf{NTFS:} Là nền tảng không thể thiếu của hệ điều hành Windows. Với bộ tính năng doanh nghiệp phong phú, bao gồm bảo mật ACLs, mã hóa, nén dữ liệu và khả năng phục hồi mạnh mẽ, NTFS là lựa chọn mặc định cho các ổ đĩa hệ thống và dữ liệu trong môi trường Windows, đặc biệt là các máy trạm và máy chủ đòi hỏi độ tin cậy và khả năng quản trị cao.
\end{itemize}

Với việc đã thiết lập một cơ sở so sánh tổng quan, báo cáo sẽ tiếp tục đi sâu vào nghiên cứu điển hình về kiến trúc NTFS để minh họa chi tiết hơn các khái niệm đã được thảo luận.


%======================================================================
% PHẦN 3.2: CASE STUDY: PHÂN TÍCH CHUYÊN SÂU VỀ NTFS (ĐÃ SỬA LỖI)
%======================================================================

\subsection{Case Study: A Deep Dive into the New Technology File System (NTFS)}

\subsubsection{Introduction}
Được giới thiệu lần đầu tiên cùng Windows NT 3.1, \textbf{New Technology File System (NTFS)} được Microsoft thiết kế từ đầu để thay thế hệ thống file FAT đã lỗi thời. Mục tiêu của NTFS là cung cấp một nền tảng lưu trữ mạnh mẽ, đáp ứng các yêu cầu ngày càng cao của môi trường doanh nghiệp về hiệu năng, độ tin cậy, bảo mật và khả năng quản lý các ổ đĩa dung lượng lớn \parencite{Shafiei2012}. Kể từ đó, NTFS đã trở thành hệ thống file mặc định và không thể thiếu trên tất cả các phiên bản hệ điều hành Windows hiện đại.

\subsubsection{Core Architecture: The Master File Table (MFT)}
Kiến trúc của NTFS xoay quanh một triết lý thiết kế trung tâm: \textit{"mọi thứ trên volume đều là một file"} \parencite{Shafiei2012}. Điều này bao gồm cả chính các cấu trúc metadata của hệ thống file. Trái tim của kiến trúc này là một file đặc biệt có tên là \textbf{\$MFT}, hay \textbf{Master File Table}. Về bản chất, MFT là một cơ sở dữ liệu quan hệ, chứa ít nhất một bản ghi (record) --- thường có kích thước cố định là 1024 byte --- cho mỗi file và thư mục tồn tại trên volume \parencite{HarvardCS161Journaling}.

Mỗi bản ghi MFT chứa một tập hợp các \textbf{thuộc tính (attributes)} mô tả đầy đủ về file hoặc thư mục đó. Các thuộc tính này bao gồm metadata cơ bản như \texttt{\$STANDARD\_INFORMATION} (chứa dấu thời gian, quyền sở hữu) và \texttt{\$FILE\_NAME} (tên file), cũng như một thuộc tính đặc biệt quan trọng là \texttt{\$DATA} \parencite{Shafiei2012}. Một trong những tối ưu hóa hiệu năng độc đáo nhất của NTFS nằm ở cách nó xử lý thuộc tính \texttt{\$DATA}:
\begin{itemize}
    \item \textbf{Resident Data (Dữ liệu nội trú):} Đối với các file có kích thước rất nhỏ, thay vì cấp phát một khối riêng trên đĩa, toàn bộ dữ liệu của file sẽ được lưu trữ trực tiếp bên trong thuộc tính \texttt{\$DATA} ngay trong bản ghi MFT. Việc này loại bỏ hoàn toàn một thao tác truy cập đĩa, giúp đọc các file nhỏ với tốc độ cực nhanh \parencite{CIRCL2023}.
    
    \item \textbf{Non-resident Data (Dữ liệu không nội trú):} Khi dữ liệu của file vượt quá không gian còn lại trong bản ghi MFT, nó sẽ được chuyển thành dạng không nội trú. Lúc này, thuộc tính \texttt{\$DATA} không còn chứa dữ liệu nữa mà thay vào đó chứa các con trỏ trỏ đến các "dải" (extents) của các cluster trên đĩa nơi dữ liệu thực sự được lưu trữ \parencite{HarvardCS161Journaling}.
\end{itemize}

\subsubsection{Analysis of Advanced Features}
Ngoài kiến trúc MFT, sức mạnh của NTFS còn đến từ bộ tính năng doanh nghiệp phong phú được tích hợp sẵn.

\paragraph{A. Journaling and Recovery (\texttt{\$LogFile}):}
NTFS là một hệ thống file journaling hoàn chỉnh, đảm bảo tính nhất quán của volume ngay cả khi xảy ra sự cố đột ngột. Cơ chế này được triển khai thông qua một file metadata đặc biệt có tên là \textbf{\texttt{\$LogFile}} \parencite{Shafiei2012}. Không giống như ext3 sử dụng "physical logging" (ghi lại toàn bộ khối metadata bị thay đổi), NTFS triển khai một hình thức ghi nhật ký tinh vi hơn gọi là \textbf{operation logging} (hay redo/undo logging). Trong mô hình này, journal không ghi lại toàn bộ khối dữ liệu mà chỉ ghi lại các thao tác logic mô tả sự thay đổi ("redo" - làm lại) và cách để hoàn tác thay đổi đó ("undo" - làm lại) \parencite{HarvardCS161Journaling}. Khi một giao dịch được cam kết, hệ điều hành sẽ thực hiện các thay đổi. Nếu hệ thống gặp sự cố, trong quá trình phục hồi, NTFS sẽ quét \texttt{\$LogFile}, "redo" lại các giao dịch đã hoàn thành và "undo" các giao dịch chưa hoàn thành, đảm bảo metadata của hệ thống file nhanh chóng trở lại trạng thái nhất quán.

\paragraph{B. Security: Access Control Lists (ACLs):}
NTFS cung cấp một mô hình bảo mật cực kỳ linh hoạt và chi tiết thông qua \textbf{Access Control Lists (ACLs)}. Mỗi file và thư mục trên một volume NTFS đều có một ACL, là một danh sách chứa các \textbf{Access Control Entries (ACEs)}. Mỗi ACE xác định một người dùng hoặc một nhóm cụ thể và định nghĩa một tập hợp các quyền (permissions) --- chẳng hạn như Đọc, Ghi, Thực thi --- được \textit{Cho phép (Allow)} hoặc \textit{Từ chối (Deny)} \parencite{SettingAccessControlLists}. Mô hình này, được gọi là Discretionary Access Control (DAC), cho phép quản trị viên kiểm soát truy cập ở mức độ rất chi tiết, vượt xa mô hình ba lớp (owner, group, other) của POSIX/Linux. Một quy tắc quan trọng trong NTFS là một ACE "Deny" sẽ luôn được ưu tiên hơn một ACE "Allow", cung cấp một cơ chế mạnh mẽ để khóa quyền truy cập một cách tường minh \parencite{Allison1998}.

\paragraph{C. Other Enterprise Features:}
\begin{itemize}
    \item \textbf{Volume Shadow Copy Service (VSS):} Là một framework mạnh mẽ cho phép tạo các "ảnh chụp" (snapshot) nhất quán tại một thời điểm của một volume, ngay cả khi các file trên đó đang được sử dụng. VSS điều phối giữa các ứng dụng, hệ thống file và nhà cung cấp phần cứng để tạm thời đóng băng các hoạt động ghi, tạo snapshot, sau đó cho phép hoạt động trở lại. Cơ chế này (thường sử dụng kỹ thuật copy-on-write) là nền tảng cho các tính năng như sao lưu trực tuyến (online backup) và System Restore trong Windows \parencite{MicrosoftVSS}.
    \item \textbf{Encryption and Compression:} NTFS hỗ trợ mã hóa và nén dữ liệu ở cấp độ file system một cách minh bạch với người dùng. \textbf{Encrypting File System (EFS)} cho phép người dùng mã hóa các file/thư mục bằng cơ chế mã hóa khóa công khai, đảm bảo chỉ người dùng đó mới có thể giải mã dữ liệu \parencite{WafaTech2025EFS}. Tính năng nén, mặt khác, giúp tiết kiệm không gian đĩa bằng cách nén dữ liệu một cách tự động khi ghi và giải nén khi đọc.
\end{itemize}

\subsubsection{Evaluation and Limitations}
\textbf{Điểm mạnh:} Kiến trúc NTFS thể hiện rõ sự vượt trội về độ tin cậy thông qua journaling, bảo mật mạnh mẽ với ACLs, và hiệu năng linh hoạt, xử lý tốt cả file nhỏ (với resident data) và file rất lớn. Bộ tính năng doanh nghiệp phong phú như VSS và EFS làm cho nó trở thành một nền tảng vững chắc cho các môi trường đòi hỏi cao.

\textbf{Điểm yếu:} Sự phức tạp của MFT và các tính năng nâng cao đi kèm với một lượng overhead metadata đáng kể so với các hệ thống file đơn giản hơn. Tuy nhiên, hạn chế lớn nhất của NTFS trong môi trường đa nền tảng là khả năng tương thích. Mặc dù các hệ điều hành như Linux và macOS có thể đọc được phân vùng NTFS, khả năng ghi dữ liệu một cách ổn định và hiệu quả thường phụ thuộc vào các driver của bên thứ ba (ví dụ: NTFS-3G), vốn được phát triển thông qua kỹ thuật dịch ngược và có thể không đạt được hiệu năng như driver gốc trên Windows \parencite{Dhjaku2019}.


%======================================================================
% PHẦN 4: BÀN LUẬN (DISCUSSION)
%======================================================================

\section{Discussion}
Các phân tích lý thuyết và nghiên cứu điển hình đã cho thấy một bức tranh đa chiều về lĩnh vực quản lý hệ thống file và lưu trữ. Rõ ràng, không có một giải pháp "tốt nhất" cho mọi trường hợp; thay vào đó, sự lựa chọn tối ưu luôn là một sự cân nhắc kỹ lưỡng giữa các yếu tố đánh đổi (trade-offs) về hiệu năng, độ tin cậy, chi phí và tính tương thích.

\subsection{Key Findings Interpretation and Design Trade-offs}
Kết quả phân tích cho thấy các hệ thống file truyền thống đã phát triển các cơ chế phức tạp để đảm bảo tính nhất quán và hiệu năng. \textbf{Journaling} là một ví dụ điển hình: nó là một "game-changer" cho độ tin cậy, nhưng cơ chế này về bản chất làm tăng gấp đôi lượng ghi cho các hoạt động siêu dữ liệu (metadata) và đôi khi cả dữ liệu người dùng \parencite{Lu2013Extending}. Sự đánh đổi này, vốn đã được chấp nhận trên HDD, lại trở thành một vấn đề nghiêm trọng hơn trên các thiết bị lưu trữ hiện đại. Tương tự, các phương pháp cấp phát là một sự cân bằng giữa hiệu năng truy cập và hiệu quả sử dụng không gian, nơi cấp phát theo chỉ mục (indexed allocation) được ưa chuộng vì tính linh hoạt của nó.

\subsection{The Impact of Modern Storage: SSDs and New Challenges}
Sự trỗi dậy của các thiết bị lưu trữ thể rắn (SSDs) đã định hình lại hoàn toàn các giả định nền tảng của việc quản lý lưu trữ. Đặc điểm vật lý của bộ nhớ flash NAND, đặc biệt là việc không có các bộ phận cơ khí chuyển động, đã làm cho các thuật toán lập lịch đĩa kinh điển (SCAN, C-SCAN, LOOK) trở nên lỗi thời, vì thời gian truy cập đến bất kỳ khối logic nào gần như là không đổi.

Tuy nhiên, kiến trúc của SSD lại giới thiệu những thách thức mới và phức tạp hơn mà các hệ thống file phải đối mặt. Khác với HDD, dữ liệu trên SSD không thể được ghi đè trực tiếp. Thay vào đó, các đơn vị bộ nhớ (page) phải được xóa trước khi ghi lại, và thao tác xóa chỉ có thể thực hiện trên các đơn vị lớn hơn nhiều gọi là "block" \parencite{Viking2017AN0035, Lu2013Extending}. Ràng buộc này là nguồn gốc của hai vấn đề lớn:

\begin{itemize}
    \item \textbf{Write Amplification (Khuếch đại ghi - WA):} Đây là hiện tượng lượng dữ liệu được ghi vật lý xuống chip flash lớn hơn lượng dữ liệu mà hệ điều hành yêu cầu ghi. Nguyên nhân chính là do quá trình \textbf{dọn rác (garbage collection - GC)}, trong đó bộ điều khiển SSD phải đọc các page hợp lệ từ một block, sao chép chúng sang một block mới, sau đó mới xóa block cũ để chuẩn bị cho các lần ghi trong tương lai. Kết quả là, một thao tác ghi logic nhỏ có thể gây ra nhiều thao tác đọc và ghi vật lý, làm giảm đáng kể hiệu năng và quan trọng hơn là tuổi thọ của ổ đĩa (được đo bằng DWPD hoặc TBW) \parencite{Viking2017AN0035}. Các yếu tố như ghi ngẫu nhiên, không gian trống thấp, và việc thiếu lệnh TRIM đều làm tăng đáng kể hệ số WA.
    \item \textbf{Wear Leveling (Cân bằng độ mòn):} Mỗi ô nhớ flash có một số chu kỳ ghi/xóa (P/E cycles) hữu hạn. Để tối đa hóa tuổi thọ, bộ điều khiển SSD phải triển khai các thuật toán cân bằng độ mòn để phân bổ các thao tác ghi đều trên toàn bộ các block nhớ.
\end{itemize}

Các hệ thống file truyền thống, với các cơ chế như journaling và cập nhật metadata thường xuyên, có thể vô tình làm trầm trọng thêm vấn đề khuếch đại ghi \parencite{Lu2013Extending}. Hơn nữa, một thách thức tinh vi khác nằm ở lệnh \textbf{FLUSH}, vốn được sử dụng để đảm bảo dữ liệu được ghi bền vững từ bộ đệm (buffer) của thiết bị xuống phương tiện lưu trữ. Trên các SSD hiện đại với bộ đệm DRAM lớn, một lệnh FLUSH "lump-sum" (ghi toàn bộ) có thể buộc hàng gigabyte dữ liệu không liên quan phải được ghi xuống, làm chậm đáng kể các hoạt động quan trọng và gây ra độ trễ lớn (long tail latency), đặc biệt trong các môi trường đa nhiệm \parencite{Yeon2018RFLUSH}. Điều này cho thấy sự tương tác giữa phần mềm (hệ điều hành/hệ thống file) và phần cứng (bộ điều khiển SSD) ngày càng trở nên quan trọng và đòi hỏi những cách tiếp cận mới để tối ưu hóa hiệu năng.

%======================================================================
% PHẦN 5: KẾT LUẬN (CONCLUSION)
%======================================================================

\section{Conclusion}
Báo cáo này đã thực hiện một cuộc khảo sát toàn diện về các nguyên tắc cơ bản và các kỹ thuật nâng cao trong lĩnh vực quản lý hệ thống file và lưu trữ của hệ điều hành. Qua việc phân tích lý thuyết, so sánh các kiến trúc, và thực hiện một nghiên cứu điển hình, các mục tiêu đề ra ban đầu đã được hoàn thành một cách có hệ thống.

\subsection{Summary of Findings}
Báo cáo đã đáp ứng đầy đủ sáu yêu cầu cốt lõi của đề tài, từ việc \textbf{định nghĩa} các khái niệm nền tảng, \textbf{giải thích} và \textbf{so sánh} các kiến trúc hệ thống file và phương pháp cấp phát, \textbf{phân tích} các thuật toán lập lịch I/O, \textbf{mô tả} các kỹ thuật tối ưu hóa, cho đến việc tiến hành một \textbf{nghiên cứu điển hình} chuyên sâu về NTFS. Các sản phẩm được yêu cầu là Sơ đồ ánh xạ logic-vật lý và Bảng so sánh các hệ thống file cũng đã được tích hợp và trình bày trong báo cáo.

\subsection{Broader Implications and Future Outlook}
Phân tích đã chỉ ra rằng lĩnh vực quản lý lưu trữ đang trong một giai đoạn chuyển đổi sâu sắc, được thúc đẩy bởi sự thay đổi trong công nghệ phần cứng. Các hệ thống file không còn có thể hoạt động như một lớp trừu tượng hoàn toàn độc lập với thiết bị bên dưới. Thay vào đó, một tương lai hợp tác chặt chẽ hơn giữa hệ điều hành và bộ điều khiển lưu trữ là tất yếu.

Các hệ thống file thế hệ mới đang dẫn đầu xu hướng này bằng cách tích hợp các tính năng được thiết kế đặc biệt để giải quyết các thách thức về quy mô và tính toàn vẹn dữ liệu trên các phương tiện lưu trữ hiện đại.
\begin{itemize}
    \item \textbf{ZFS và Btrfs} đã trở nên phổ biến nhờ vào các tính năng đột phá. Cả hai đều sử dụng cơ chế \textbf{copy-on-write (CoW)}, giúp tạo snapshot và clone một cách cực kỳ hiệu quả. Quan trọng hơn, chúng tích hợp \textbf{checksum} cho cả dữ liệu và metadata ở mọi cấp độ, cho phép tự động phát hiện và sửa chữa các lỗi dữ liệu thầm lặng (silent data corruption) khi được sử dụng cùng với các cấu hình dự phòng (như mirroring hoặc RAID-Z). Chúng cũng hợp nhất việc quản lý volume và hệ thống file, mang lại sự linh hoạt cao hơn \parencite{Nfina2025BtrfsZFS}.
    \item \textbf{ReFS (Resilient File System)} của Microsoft cũng theo đuổi một triết lý tương tự, được định vị là người kế nhiệm của NTFS trong các môi trường máy chủ đòi hỏi tính toàn vẹn và khả năng phục hồi cao. ReFS sử dụng "luồng toàn vẹn" (integrity streams) để xác thực và tự động sửa chữa dữ liệu khi được kết hợp với Storage Spaces. Các tính năng như nhân bản khối (block cloning) và VDL thưa (sparse VDL) giúp tăng tốc đáng kể các hoạt động trên máy ảo, cho thấy sự tập trung rõ rệt vào các workload hiện đại \parencite{Microsoft2025ReFS}.
\end{itemize}
Những hệ thống này báo hiệu một tương lai nơi việc quản lý lưu trữ không chỉ nhanh hơn, mà còn thông minh hơn, linh hoạt hơn, và trên hết là đáng tin cậy hơn, có khả năng tự bảo vệ dữ liệu trước các lỗi phần cứng và phần mềm không thể tránh khỏi.





% Nội dung của phần Phân tích và Nghiên cứu điển hình...

%     \subsection{Comparative Analysis}
%     Tổng hợp so sánh từ Phần 2...

%     \subsection{Case Study: NTFS Architecture}
%     Phân tích sâu về NTFS, MFT, LogFile...

% \section{Discussion}
% Nội dung của phần Bàn luận...

%     \subsection{Key Findings Interpretation}
%     Diễn giải các kết quả chính...
    
%     \subsection{Design Trade-offs}
%     Phân tích các sự đánh đổi...
    
%     \subsection{Impact of Modern Storage (SSD/NVMe)}
%     Bàn luận về tác động của SSD...

% \section{Conclusion}
% Nội dung của phần Kết luận...

% --- PHẦN TÀI LIỆU THAM KHẢO ---
\newpage
\printbibliography[title={References}]

% % --- PHẦN TUYÊN BỐ SỬ DỤNG AI ---
% \newpage
% \section*{AI Usage Statement}
% % Viết tuyên bố sử dụng AI của nhóm bạn tại đây.
% Our team used AI tools (ChatGPT, Claude) for the following purposes: (1) Grammar and spelling checking, and (2) Explaining complex technical concepts during the research phase. All core content, analysis, diagrams, and conclusions were developed independently by team members through studying primary sources including OS textbooks, technical documentation, and academic papers. No AI-generated text was directly copied into the report.

\end{document}
